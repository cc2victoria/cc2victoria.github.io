{"meta":{"title":"Cecelia's BLOG","subtitle":null,"description":null,"author":"Yanjiao Lu","url":"http://github.com"},"pages":[{"title":"categories","date":"2017-03-24T11:52:42.956Z","updated":"2017-03-24T11:52:42.956Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-03-24T11:53:04.072Z","updated":"2017-03-24T11:53:04.072Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"经常不被需要","slug":"Redux&&Flux经常不被需要？","date":"2017-06-04T10:57:30.000Z","updated":"2017-06-04T10:59:14.738Z","comments":true,"path":"2017/06/04/Redux&&Flux经常不被需要？/","link":"","permalink":"http://github.com/2017/06/04/Redux&&Flux经常不被需要？/","excerpt":"","text":"Redux/Flux 经常不被需要？ 原文地址：Redux/Flux is often (usually?) not needed 时间: 2017/6/4 目录 Redux/Flux 经常不被需要？ 目录 前言 后台CRUD应用 那么什么时候应该使用Redux? 我的建议 结论 前言我发现很多React开发新手都假定Redux是React平台的一部分。实际上它不是。和许多开始使用React的团队一起工作，所以我相当了解他们遇到的问题。而且，人们使用React遇到的前10的问题，没有一个是使用Redux和Flux解决的。 附注：Flux是一种模式，而Redux是实现这种模式的框架。实际上，在这篇文章中我是在谈论两者。 我不是唯一一个提出此观点的人。下面是引用Pete Hunt(React 创建者之一)的一段话： 很多开发者一坐下开始开发一个应用并且定义他们的数据模型，他们认为他们需要使用Flux来做这些。这是错误的采用Flux的方法。 下面是篇博文来自 Dan Abramov，Redux的创建者，基本上说的是同样的事情。你可能不需要Redux。这是他唯一一篇保持置顶的博文。 下面一段引文来自 Ryan Florence, 一个在 React 生态系统有受人尊重的很大的成就和会议频繁发言人: Flux 阻碍了React的创新：让所有人再次回到事件和‘模板’并且熟悉数据的改变。 后台CRUD应用有一类明确的应用，我认为不需要Redux: 传统的业务CRUD应用。我的许多客户和学生属于这一类。此类的应用有成百个页面，每一个都有他们自己的路由。但是这些页面中的大多数可以单机显示，而且主要通过数据库集成。所以当此类应用作为一个整体的时候可能会非常复杂，作为单页面的时候就不是这样复杂。不像Facebook那样复杂。 那么什么时候应该使用Redux?如果我有更多时间，我愿意探讨究竟Redux解决了什么问题和什么场景使用它的细节。但是我愿意把它留在下篇博文中。但是通常，当客户开始列举他们需要Redux的原因时，我经常可以告诉他们怎样使用传统的纯React并且使用更少的操作。 我的建议等待直到你的应用组件复杂,并且你遇到一些特定的问题，而且该问题你确定可以用Redux解决，再使用Redux。 结论总之，我会说Redux不应该被作为大多数应用的默认选择，特别是，我的学生和客户创建的大多数应用。我认为在投身于Redux之前，至少有100件事情他们应该学习。","raw":null,"content":null,"categories":[],"tags":[{"name":"Redux Flux React","slug":"Redux-Flux-React","permalink":"http://github.com/tags/Redux-Flux-React/"}]},{"title":"提高webpack构建效率之DLLPlugin","slug":"提高webpack构建效率之DLLPlugin","date":"2017-05-24T15:23:09.000Z","updated":"2017-05-24T16:59:41.025Z","comments":true,"path":"2017/05/24/提高webpack构建效率之DLLPlugin/","link":"","permalink":"http://github.com/2017/05/24/提高webpack构建效率之DLLPlugin/","excerpt":"","text":"1.前言webpack是一个将前端资源模块化打包的工具。借助该工具，我们在项目开发的过程中，可以更便宜的处理模块间的依赖关系。而commonjs的模块和ES6的处理代码必须在浏览器使用前，经过webpack的构建。 模块会随着项目的进展而逐渐增多，随之webpack打包的时间也会加长。最近开发的项目，经过基本的优化，打包的时间已经超过120s, 而改动代码后，至少也要10s页面才能重新刷新。如此，开阿发效率大大降低。 2. CommonsChunkPlugin分析了下(这儿可以贴张图)，主要占打包资源的是依赖的React，axios、semantic-react-ui等等引入的包依赖，在执行node webpack.config.js的时候，所有的依赖都会重新打包一遍。之前我采用的是CommonsChunkPlugin来对相同的模块，单独提取出来打包，进而减小rebuild的性能。 var config = { // 入口文件 entry: { app: [&apos;./index.js&apos;], lib: [ &apos;react&apos;, &apos;react-dom&apos;, &apos;react-router&apos;, &apos;redux&apos;, &apos;react-redux&apos;, &apos;redux-thunk&apos; ], }, output: { path: &apos;./&apos;, filename: &apos;[name].js&apos;, }, plugins: [ // 提取共同模块 new webpack.optimize.CommonsChunkPlugin({ names: [&apos;lib&apos;, &apos;app&apos;] }), ] } 然而CommonsChunkPlugin只在rebuild的时候有一点效果，初次运行的时间仍然没有变。 网上搜索加上实际操作，终于让我找到了解决方法。 3. DLL &amp; DllReferenceDLL DLL 插件不执行任何模块的代码，只是引入模块。最终导出一个可以用于通过id（内部引入函数）来引入模块的函数和一个被写入特殊位置的manifest.json文件，该文件包含实际请求到模块id的映射。 详细参考 dllplugin 该插件结合output.library选项，使dll方法可以在全局范围内使用。 webpack.dll.js new DllPlugin({ path: path.join(__dirname, &quot;manifest.json&quot;), name: &quot;[name]_[hash]&quot;, context: __dirname }) path : manifest文件生成的位置，绝对路径 name : dll 方法的名称（与 output.library 保持一致） context (可选) : manifest文件中请求（对模块的引入请求）的上下文环境，默认与webpack环境保持一致 DllReference ss 详细参考 dllreferenceplugin webpack.config.js new DllReferencePlugin({ context: __dirname, scope: &quot;xyz&quot;, manifest: require(&quot;./manifest.json&quot;), name: &quot;./my-dll.js&quot;, sourceType: &quot;commonsjs2&quot;, content: { ... } }) context: (absolute path) context of requests in the manifest (or content property) scope (optional): prefix which is used for accessing the content of the dllmanifest (object): an object containing content and name name (optional): the name where the dll is exposed (defaults to manifest.name) (see also externals) sourceType (optional): the type how the dll is exposed (defaults to “var”) (see also externals) content (optional): the mappings from request to module id (defaults to manifest.content) 4. 实际操作 在根目录单独建立一个 webpack.dll.js var webpack = require(&apos;webpack&apos;) module.exports = { output: { path: &apos;./dll&apos;, filename: &apos;[name].js&apos;, /** * output.library * 将会定义为 window.${output.library} * 在这次的例子中，将会定义为`window.vendor_library` */ library: &apos;[name]_library&apos;, libraryTarget: &apos;commonjs2&apos; }, entry: { // 入口，依赖的外部模块 vendor: [ &apos;react&apos;, &apos;react-dom&apos;, &apos;react-router&apos;, &apos;redux&apos;, &apos;react-redux&apos;, &apos;redux-thunk&apos;, &apos;semantic-ui-react&apos;, &apos;lodash&apos;, &apos;echarts&apos;, &apos;axios&apos; ] }, plugins: [ new webpack.DllPlugin({ /** * path * 定义 manifest 文件生成的位置 * [name]的部分由entry的名字替换 */ path: &apos;./dll/[name]-manifest.json&apos;, /** * name * dll bundle 输出到那个全局变量上 * 和 output.library 一样即可。 */ name: &apos;[name]&apos;, context: __dirname }) ] } 生成dll文件 执行./node_modules/.bin/webpack --config build/webpack.config.js。 请在每次依赖的模块更改时重新执行这个命令 在index.html中引入dll文件 这一步必不可少，之前因为少了这一步，一直报 vendor_library not defined //这个模块的引入必须在自定义文件的入口之前 &lt;script src=&quot;dist/dll/vendor.dll.js&quot;&gt;&lt;/script&gt; webpack.config.js var webpack = require(&apos;webpack&apos;) module.exports = { output: { path: __dirname, filename: &apos;[name].bundle.js&apos;, }, entry: { app: [&apos;./app.js&apos;] }, plugins: [ new webpack.DllReferencePlugin({ context: __dirname, manifest: require(&apos;./dll/test-manifest.json&apos;), sourceType: &apos;commonjs2&apos;, name: &apos;./dll/test.js&apos; }) ] } BugFixed配置中常可能会出现的问题： vendor not defined : 模块没有在html中引入，在根目录文件夹中加入script标签引入dll文件。 打包时间没有变快： 检查下webpack.config.js的context是否和webpack.config.js的一致，不一致的话保持一致，一般这个context的默认值是开发项目的根路径。 参考 Webpack Plugins we been keepin on the DLL","raw":null,"content":null,"categories":[{"name":"webpack","slug":"webpack","permalink":"http://github.com/categories/webpack/"}],"tags":[{"name":"webpack DLLPlugin DllReferencePlugin","slug":"webpack-DLLPlugin-DllReferencePlugin","permalink":"http://github.com/tags/webpack-DLLPlugin-DllReferencePlugin/"}]},{"title":"php 安装和开启外部扩展库","slug":"php-安装和开启外部扩展库","date":"2017-04-26T15:49:08.000Z","updated":"2017-05-24T15:26:39.325Z","comments":true,"path":"2017/04/26/php-安装和开启外部扩展库/","link":"","permalink":"http://github.com/2017/04/26/php-安装和开启外部扩展库/","excerpt":"","text":"php 安装和开启外部扩展库不得不说，由于php的扩展问题，我在安装和运行php相关项目的时候遇到了很多的坑。例如之前搭建php的Laravel框架，以及最近搭建的 phpmyadmin项目，都遇到了不少缺少库的问题：由于缺少像openssl、mysqli、postgres等外部扩展库，导致程序不能正常运行。但是我们项目通常用到的php是已经编译好的，而且服务器上的安装包的外部扩展不是很全。所以不能通过重新编译php的办法来解决这个问题，且重新编译的话可能导致其他很多的问题。 是不是很绝望？ 经过一番折腾，终于找到解决方法，整理如下： 检测扩展首先检查下扩展有没有加载，如果已经加载了，那基本是99%的可能性确定问题不是出现在扩展库这个地方了。 phpinfo()利用phpinfo()这个方法可以查看当前安装的php包含的扩展有哪些。 bugfixed在安装的时候我遇到了一个很难发现的bug: 在linux端通过php -m命令，我看到了一些我已经安装的扩展，但是在浏览器端通过phpinfo()方法，却发现缺少很多已经安装的库。后来找到原因，Apache中配置的php.ini的位置不对。如果出现类似的问题，不妨检查下Apache根目录下conf文件夹中的http.conf的配置是否正确 安装和开启废话辣么多，终于可以开始说正题了。windows环境新增外部扩展的方法请参考php开启openssl的方法,openssl安装。本文主要介绍linux centos7的安装方法。 php版本： php-5.6.4 这个地方由于我们服务器上的安装包内的文件不是很全，官网上下载也不是很方便，所以这个地方推荐用搜狐的镜像来下载。地址为：http://mirrors.sohu.com/php/ 首先，进入到我们的主机： # 下载对应的php到/opt/php目录下 cd /opt/php wget http://mirrors.sohu.com/php/php-5.6.4.tar.gz # 解压 tar zxvf php-5.6.4.tar.gz # 进入PHP的openssl扩展模块目录 cd php-5.6.4/ext/openssl/ /opt/php/bin/phpize # 这里为你自己的phpize路径，如果找不到，使用whereis phpize查找 # 执行后，发现错误 无法找到config.m4 ，config0.m4就是config.m4。直接重命名 mv config0.m4 config.m4 /opt/php/bin/phpize ./configure --with-openssl --with-php-config=/opt/php/bin/php-config make make install # 安装完成后，会返回一个.so文件（openssl.so）的目录。在此目录下把openssl.so 文件拷贝到你在php.ini 中指定的 extension_dir 下（在php.ini文件中查找：extension_dir =），我这里的目录是 var/www/php5/lib/php/extensions # 编辑php.ini文件，在文件最后添加 extension=openssl.so # 重启Apache即可 /opt/apache2/bin/httpd restart","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://github.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://github.com/tags/php/"}]},{"title":"linux 常用命令","slug":"linux-常用命令","date":"2017-03-24T13:57:01.000Z","updated":"2017-03-24T14:04:27.231Z","comments":true,"path":"2017/03/24/linux-常用命令/","link":"","permalink":"http://github.com/2017/03/24/linux-常用命令/","excerpt":"","text":"基本软件： 拷贝 apache ngnix php common 一键安装环境 tar 解压 tar -zvxf v 查看过程 压缩 tar -zvcf 添加执行权限 chmod +x 可执行 w 写 r读 d目录 chmod +755 执行 ./install.sh () 默认系统执行权限（不推荐）：/bin/ssh install.sh 查看执行脚本 apache启动脚本 danahttpd 查看指令详细信息，以ps为例 man ps ps –help ps 命令使用（查看服务是否启动） s ystemctl status danahttpd ps aux | grep dana | grep -v grep ps -ef | grep dana 启动服务 systemctl start 服务名 进入 init.d目录下，通过 ./ 启动 如： ./ngnix restart ngnix 位置 /etc/ngnix/ngnix.d 可以通过安装脚本查看 vim ：set nu 设置代码行号 非插入状态： 行数 + G 如：80 G 访问底部 G + shift 访问顶部 gg 退出 ：wq :q :q! 远程传输 scp 拷贝 cp 和 scp（建议用于单个文件拷贝） scp 文件 root@192.168.1.203:/home scp -P 端口号 sr（源文件） dest（目标文件） scp -P 5222 root@180.168.94.118:/jp,e/test.file /home/ scp -P 5222 root@180.168.94.118:/home/test.file root@192.168.1.3:/home/ (端口必须一致) 远程连接 ssh 安装 yum install XXX yum search mysql (查找版本 安装时补全版本号) yum update（更新安装仓库） 安装对应安装包目录 /var/cache/yum/xb6_64 安装.rpm 格式的文件 rpm -ivh xxx.rpm 查看软件是否安装： rpm -qa|grep python 删除 rpm -e xxx 查看端口号活动 netstat netstat -anp|grep cayman 挂载 查看挂载 lsbsk 格式化 mkfs.xfs -f /dev/sdd 挂载 mount /dev/sdd /home/ 查看挂载 df -hT 软连接 -s ln -s dest sr 查看主机名称 /etc/hosts 查看ssh的信息 /etc/.ssh/","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"http://github.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://github.com/tags/linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-06T15:37:41.973Z","updated":"2017-03-06T15:49:27.857Z","comments":true,"path":"2017/03/06/hello-world/","link":"","permalink":"http://github.com/2017/03/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]},{"title":"React 知识学习图谱","slug":"React-知识图谱","date":"2016-12-14T07:17:31.000Z","updated":"2017-03-24T11:55:10.659Z","comments":true,"path":"2016/12/14/React-知识图谱/","link":"","permalink":"http://github.com/2016/12/14/React-知识图谱/","excerpt":"","text":"#React 知识学习图谱 背景由于目前的项目还是使用传统的架构和前端技术。在从特点，应用场景和实战应用几个方面考虑，决定采用React技术栈：前端技术选型。 React 知识图谱从项目的实际角度出发，列出了如下React的知识学习图谱： 根据以上图谱顺序，列出React项目学习路线如下: 01 React 基础知识 02 Babel 转码: 项目必须。可以直接在js代码中引入，也可以通过命令行将代码转码。 03 路由：非项目必须。主要应用于单页面程序中，管理地址栏。实现页面的路由的映射，参数的解析和传递。 04 React 工程化 03-1 ES6新特性：非项目必需。作为Javascript的最新发布的标准，ES6的新特性和新接口可以让代码更加简洁和优美。ES6新增模块部分跟React的设计能更好的契合。 03-2 服务端 Node：非项目必须。但是如果要用JS来写服务端程序，则需要Node。 NPM：非项目必须。NPM是包管理工具，可以通过NPM来安装项目的一些依赖和管理依赖的版本。 03-3 打包编译：非项目必须。webpack是模块打包和编译工具，主要功能是产品化和模块打包以及将代码编译成浏览器或者Node可识别的代码。 Flux 架构:非项目必须。React只是DOM的抽象层，所以它只能作为应用架构的视图层。而Flux是一种项目应用架构，最大的特点是数据单向流动，如下图： 架构的主要作用是管理 Store 和 View 之间的关系。 06 React组件库的使用方法：React 有很多第三方插件库，如：Bootstrap，D3。第三方插件库的引入和使用，使项目必须。 07 React测试和性能工具:非项目必需。当项目运行到慢慢变得比较大的时候，对于前端性能的分析和代码的测试就变得有必要了 参考 如何学习React | Github React 技术栈系列教程 | Blog react 知识结构 | csdn","raw":null,"content":null,"categories":[{"name":"react 学习","slug":"react-学习","permalink":"http://github.com/categories/react-学习/"}],"tags":[{"name":"react","slug":"react","permalink":"http://github.com/tags/react/"}]}]}