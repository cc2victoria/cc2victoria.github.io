{"meta":{"title":"Cecelia's BLOG","subtitle":null,"description":null,"author":"Yanjiao Lu","url":"http://cc2victoria.github.io"},"pages":[{"title":"categories","date":"2017-03-24T11:52:42.956Z","updated":"2017-03-24T11:52:42.956Z","comments":true,"path":"categories/index.html","permalink":"http://cc2victoria.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-03-24T11:53:04.072Z","updated":"2017-03-24T11:53:04.072Z","comments":true,"path":"tags/index.html","permalink":"http://cc2victoria.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"linux如何访问外网？","slug":"linux如何访问外网？","date":"2017-08-15T15:05:51.000Z","updated":"2017-08-15T16:03:17.805Z","comments":true,"path":"2017/08/15/linux如何访问外网？/","link":"","permalink":"http://cc2victoria.github.io/2017/08/15/linux如何访问外网？/","excerpt":"\n新配置的一台linux, 环境装上了，但是yum这些命令什么的一直连接不上，服务一直报Connection failed， 这种情况可以尝试下ping baidu.com，看看返回结果，如果识别或者解析不了，那么就应该是linux访问不到外网的问题。","text":"新配置的一台linux, 环境装上了，但是yum这些命令什么的一直连接不上，服务一直报Connection failed， 这种情况可以尝试下ping baidu.com，看看返回结果，如果识别或者解析不了，那么就应该是linux访问不到外网的问题。 导致linux连接不上外网的原因可能有如下： 防火墙未关闭 查看防火墙状态：systemctl status firewalld 关闭防火墙：systemctl stop firewalld 关闭防火墙开机自启： systemctl disable firewallld 防火墙开机自启关闭失败了？？？：解决方法：修改 selinux配置，并将其设置为disabled如下： 再执行步骤3 reboot 重启虚拟机 设置nameserver vi /etc/resolve.conf 设置代理，添加如下代码 nameserver 192.168.1.1","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"http://cc2victoria.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://cc2victoria.github.io/tags/linux/"}]},{"title":"React-组件解耦之道（译）","slug":"React-组件解耦之道（译）","date":"2017-07-08T06:53:02.000Z","updated":"2017-08-15T16:10:55.820Z","comments":true,"path":"2017/07/08/React-组件解耦之道（译）/","link":"","permalink":"http://cc2victoria.github.io/2017/07/08/React-组件解耦之道（译）/","excerpt":"\nReact组件非常灵活可扩展，不过随着业务复杂度的增加和许多外部工具库的引入，组件会随着时间的推移而更加庞大，最终往往会变得浮肿。","text":"React组件非常灵活可扩展，不过随着业务复杂度的增加和许多外部工具库的引入，组件会随着时间的推移而更加庞大，最终往往会变得浮肿。 如同任何其他种类的编程语言，遵守单一功能原则不仅使您的组件更易于维护，而且还可以实现更多的复用。然而，了解怎样分离一个庞大React组件的功能并不总是那么容易。下面有三种React组件解耦的方法，从最简单的到最高阶： 拆分 render() 方法这是最显而易见的应用方法：当一个组件渲染太多的元素时，简化此类组件的一个简单方法是将这些元素分解为成逻辑子组件。 拆分rende()方法最常见和最快速的方法 是在同一个类中创建子渲染方法： class Panel extends React.Component { renderHeading() { // ... } renderBody() { // ... } render() { return ( &lt;div&gt; {this.renderHeading()} {this.renderBody()} &lt;/div&gt; ); } } 尽管这个方法有一定的作用，但是并没有分解组件本身。组件内所有的state、porps和类的方法仍然是共享的，因此很难确定他们是被哪个渲染方法使用。 要正真的减少组件的复杂度，就应该创建全新的组件来替代。为了简化子组件，函数式组件可以用来保持模板最小化。 const PanelHeader = (props) =&gt; ( // ... ); const PanelBody = (props) =&gt; ( // ... ); class Panel extends React.Component { render() { return ( &lt;div&gt; // Nice and explicit about which props are used &lt;PanelHeader title={this.props.title}/&gt; &lt;PanelBody content={this.props.content}/&gt; &lt;/div&gt; ); } } 通过这种方法实现拆分组件由一个微妙但是非常重要的差别。通过将直接的方法调用替换为为间接的组件声明，我们产生了更小的单元来影响React。这是因为Panel的render()方法的返回值是一个元素索引树，它仅仅只执行到 PanelHeader和PanelBody，而不是它下面所有的元素。 这些对测试也有实际的意义：一个浅层渲染可以被用来轻松隔离这些单元，进行独立测试。当新的React算法体系发布时，较小的单元将允许更高效的执行增量渲染。 通过porps传递React元素来模板化组件当一个组件因为多个变量或者配置变得更复杂时，就该考虑将这个组件转换成一个简单的拥有一个或者更多开放的接口的“模板”组件。这将使父组件的功能集中在配置这一块。 例如：一个Comment组件可能拥有不同的行为和显示不同的元数据，这取决于你是否是作者，评论是否成功保存，或者你拥有哪些权限。与其将Comment组件的结构（如何和在哪里呈现组件的内容）和处理所有可能变量的逻辑混合，不如考虑独立实现这两个问题。利用React的props传递元素的功能，而不仅仅是传递数据来创建一个灵活的模板组件。 组件模板 class CommentTemplate extends React.Component { static propTypes = { // Declare slots as type node metadata: PropTypes.node, actions: PropTypes.node, }; render() { return ( &lt;div&gt; &lt;CommentHeading&gt; &lt;Avatar user={...}/&gt; // Slot for metadata &lt;span&gt;{this.props.metadata}&lt;/span&gt; &lt;/CommentHeading&gt; &lt;CommentBody/&gt; &lt;CommentFooter&gt; &lt;Timestamp time={...}/&gt; // Slot for actions &lt;span&gt;{this.props.actions}&lt;/span&gt; &lt;/CommentFooter&gt; &lt;/div&gt; ); } } 接着，另外一个组件可以单独负责计算出填充元数据和行为接口的内容 逻辑组件 class Comment extends React.Component { render() { const metadata = this.props.publishTime ? &lt;PublishTime time={this.props.publishTime} /&gt; : &lt;span&gt;Saving...&lt;/span&gt;; const actions = []; if (this.props.isSignedIn) { actions.push(&lt;LikeAction /&gt;); actions.push(&lt;ReplyAction /&gt;); } if (this.props.isAuthor) { actions.push(&lt;DeleteAction /&gt;); } return &lt;CommentTemplate metadata={metadata} actions={actions} /&gt;; } } 时刻牢记在JSX语法中，在一个组件开合标签中的任何内容都可以作为特殊的children属性来传递。当该属性使用正确的时候，表现的尤为明显。为了符合语言习惯，它应该被保留用作内容的主要区域。在Comment这个例子当中，这个值应该为评论文本本身。 &lt;CommentTemplate metadata={metadata} actions={actions}&gt; {text} &lt;/CommentTemplate&gt; 将公共内容提取到高阶组件中组件经常会被与其主要目的不直接相关的交叉问题污染。 假设你想在Document组件中的任意超链接触发时发送分析数据，进一步复杂假设，发送的数据需要包含Document的一些信息，如它的ID。最显而易见的方法可能是在文档组件的生命周期方法componentDidMount和componentWillUnmount中添加代码，如下： class Document extends React.Component { componentDidMount() { ReactDOM.findDOMNode(this).addEventListener(&apos;click&apos;, this.onClick); } componentWillUnmount() { ReactDOM.findDOMNode(this).removeEventListener(&apos;click&apos;, this.onClick); } onClick = (e) =&gt; { if (e.target.tagName === &apos;A&apos;) { // Naive check for &lt;a&gt; elements sendAnalytics(&apos;link clicked&apos;, { documentId: this.props.documentId // Specific information to be sent }); } }; render() { // ... } } 但是这样做可能会有如下问题： 组件现在有一个额外的使它的主要目的难理解的问题：渲染文档 如果组件在生命周期方法中有额外的处理逻辑，那么分析代码将变得更难理解。 分析代码不可复用 重新构建组件变得更加困难，因为你必须解决分析代码 拆分这样的内容可以通过高阶函数（HOCs）实现。 简而言之，这些方法可以应用于任何React组件，如果用所需的行为包裹该组件。 高阶函数 function withLinkAnalytics(mapPropsToData, WrappedComponent) { class LinkAnalyticsWrapper extends React.Component { componentDidMount() { ReactDOM.findDOMNode(this).addEventListener(&apos;click&apos;, this.onClick); } componentWillUnmount() { ReactDOM.findDOMNode(this).removeEventListener(&apos;click&apos;, this.onClick); } onClick = (e) =&gt; { if (e.target.tagName === &apos;A&apos;) { // Naive check for &lt;a&gt; elements const data = mapPropsToData ? mapPropsToData(this.props) : {}; sendAnalytics(&apos;link clicked&apos;, data); } }; render() { // Simply render the WrappedComponent with all props return &lt;WrappedComponent {...this.props} /&gt;; } } return LinkAnalyticsWrapper; } 注意以下很重要：该高阶函数不会改变组件以添自己的行为，但是他会返回一个新的包裹组件。就是一个新的包裹组件来替代原有的Document组件： class Document extends React.Component { render() { // ... } } export default withLinkAnalytics((props) =&gt; ({ documentId: props.documentId }), Document); 请注意一个特殊的细节，发送什么样的数据（documentId）可以被HOC提取为配置。该数据使文件的作用域信息，Document组件和HOC中withLinkAnalytics点击事件的通用功能保持一致。 高阶组件展现了React组件的强大的组件化特性。这个简单的例子展示了如何将看起来紧耦合的代码如何被解耦成拥有单一功能的模块。 HOC经常被用在React库中，如：react-redux，styled-components和react-intl。毕竟，这些库都是关于解决React应用通用方面的问题。另一个库，recompose,更进一步为和组件状态和生命周期方法所有方法使用HOC。 ###总结### React组件被设计为高组合。通过易于解耦和组装他们来使用盖特点变为你的优点。不要因为创建小而功能专一的组件而害羞。可能在最开始写代码的时候感觉笨拙，但是写出来的代码将更强大，更易于复用。 原文地址： Techniques for decomposing React components","raw":null,"content":null,"categories":[{"name":"react","slug":"react","permalink":"http://cc2victoria.github.io/categories/react/"},{"name":"components","slug":"react/components","permalink":"http://cc2victoria.github.io/categories/react/components/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cc2victoria.github.io/tags/react/"},{"name":"components","slug":"components","permalink":"http://cc2victoria.github.io/tags/components/"}]},{"title":"Redux&&Flux经常不被需要？","slug":"Redux&&Flux经常不被需要？","date":"2017-06-04T10:57:30.000Z","updated":"2017-08-15T16:46:49.006Z","comments":true,"path":"2017/06/04/Redux&&Flux经常不被需要？/","link":"","permalink":"http://cc2victoria.github.io/2017/06/04/Redux&&Flux经常不被需要？/","excerpt":"\n前言我发现很多React开发新手都假定Redux是React平台的一部分。实际上它不是。和许多开始使用React的团队一起工作，所以我相当了解他们遇到的问题。而且，人们使用React遇到的前10的问题，没有一个是使用Redux和Flux解决的。","text":"前言我发现很多React开发新手都假定Redux是React平台的一部分。实际上它不是。和许多开始使用React的团队一起工作，所以我相当了解他们遇到的问题。而且，人们使用React遇到的前10的问题，没有一个是使用Redux和Flux解决的。附注：Flux是一种模式，而Redux是实现这种模式的框架。实际上，在这篇文章中我是在谈论两者。 我不是唯一一个提出此观点的人。下面是引用Pete Hunt(React 创建者之一)的一段话： 很多开发者一坐下开始开发一个应用并且定义他们的数据模型，他们认为他们需要使用Flux来做这些。这是错误的采用Flux的方法。 下面是篇博文来自 Dan Abramov，Redux的创建者，基本上说的是同样的事情。你可能不需要Redux。这是他唯一一篇保持置顶的博文。 下面一段引文来自 Ryan Florence, 一个在 React 生态系统有受人尊重的很大的成就和会议频繁发言人: Flux 阻碍了React的创新：让所有人再次回到事件和‘模板’并且熟悉数据的改变。 目录 Redux/Flux 经常不被需要？ 前言 目录 后台CRUD应用 那么什么时候应该使用Redux? 我的建议 结论 后台CRUD应用有一类明确的应用，我认为不需要Redux: 传统的业务CRUD应用。我的许多客户和学生属于这一类。此类的应用有成百个页面，每一个都有他们自己的路由。但是这些页面中的大多数可以单机显示，而且主要通过数据库集成。所以当此类应用作为一个整体的时候可能会非常复杂，作为单页面的时候就不是这样复杂。不像Facebook那样复杂。 那么什么时候应该使用Redux?如果我有更多时间，我愿意探讨究竟Redux解决了什么问题和什么场景使用它的细节。但是我愿意把它留在下篇博文中。但是通常，当客户开始列举他们需要Redux的原因时，我经常可以告诉他们怎样使用传统的纯React并且使用更少的操作。 我的建议等待直到你的应用组件复杂,并且你遇到一些特定的问题，而且该问题你确定可以用Redux解决，再使用Redux。 结论总之，我会说Redux不应该被作为大多数应用的默认选择，特别是，我的学生和客户创建的大多数应用。我认为在投身于Redux之前，至少有100件事情他们应该学习。 原文地址：Redux/Flux is often (usually?) not needed","raw":null,"content":null,"categories":[{"name":"react","slug":"react","permalink":"http://cc2victoria.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cc2victoria.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://cc2victoria.github.io/tags/redux/"},{"name":"flux","slug":"flux","permalink":"http://cc2victoria.github.io/tags/flux/"}]},{"title":"提高webpack构建效率之DLLPlugin","slug":"提高webpack构建效率之DLLPlugin","date":"2017-05-24T15:23:09.000Z","updated":"2017-08-15T16:28:20.084Z","comments":true,"path":"2017/05/24/提高webpack构建效率之DLLPlugin/","link":"","permalink":"http://cc2victoria.github.io/2017/05/24/提高webpack构建效率之DLLPlugin/","excerpt":"\n1.前言webpack是一个将前端资源模块化打包的工具。借助该工具，我们在项目开发的过程中，可以更便宜的处理模块间的依赖关系。而commonjs的模块和ES6的处理代码必须在浏览器使用前，经过webpack的构建。","text":"1.前言webpack是一个将前端资源模块化打包的工具。借助该工具，我们在项目开发的过程中，可以更便宜的处理模块间的依赖关系。而commonjs的模块和ES6的处理代码必须在浏览器使用前，经过webpack的构建。模块会随着项目的进展而逐渐增多，随之webpack打包的时间也会加长。最近开发的项目，经过基本的优化，打包的时间已经超过120s, 而改动代码后，至少也要10s页面才能重新刷新。如此，开阿发效率大大降低。 2. CommonsChunkPlugin分析了下(这儿可以贴张图)，主要占打包资源的是依赖的React，axios、semantic-react-ui等等引入的包依赖，在执行node webpack.config.js的时候，所有的依赖都会重新打包一遍。之前我采用的是CommonsChunkPlugin来对相同的模块，单独提取出来打包，进而减小rebuild的性能。 var config = { // 入口文件 entry: { app: [&apos;./index.js&apos;], lib: [ &apos;react&apos;, &apos;react-dom&apos;, &apos;react-router&apos;, &apos;redux&apos;, &apos;react-redux&apos;, &apos;redux-thunk&apos; ], }, output: { path: &apos;./&apos;, filename: &apos;[name].js&apos;, }, plugins: [ // 提取共同模块 new webpack.optimize.CommonsChunkPlugin({ names: [&apos;lib&apos;, &apos;app&apos;] }), ] } 然而CommonsChunkPlugin只在rebuild的时候有一点效果，初次运行的时间仍然没有变。 网上搜索加上实际操作，终于让我找到了解决方法。 3. DLL &amp; DllReferenceDLL DLL 插件不执行任何模块的代码，只是引入模块。最终导出一个可以用于通过id（内部引入函数）来引入模块的函数和一个被写入特殊位置的manifest.json文件，该文件包含实际请求到模块id的映射。 详细参考 dllplugin 该插件结合output.library选项，使dll方法可以在全局范围内使用。 webpack.dll.js new DllPlugin({ path: path.join(__dirname, &quot;manifest.json&quot;), name: &quot;[name]_[hash]&quot;, context: __dirname }) path : manifest文件生成的位置，绝对路径 name : dll 方法的名称（与 output.library 保持一致） context (可选) : manifest文件中请求（对模块的引入请求）的上下文环境，默认与webpack环境保持一致 DllReference ss 详细参考 dllreferenceplugin webpack.config.js new DllReferencePlugin({ context: __dirname, scope: &quot;xyz&quot;, manifest: require(&quot;./manifest.json&quot;), name: &quot;./my-dll.js&quot;, sourceType: &quot;commonsjs2&quot;, content: { ... } }) context: (absolute path) context of requests in the manifest (or content property) scope (optional): prefix which is used for accessing the content of the dllmanifest (object): an object containing content and name name (optional): the name where the dll is exposed (defaults to manifest.name) (see also externals) sourceType (optional): the type how the dll is exposed (defaults to “var”) (see also externals) content (optional): the mappings from request to module id (defaults to manifest.content) 4. 实际操作 在根目录单独建立一个 webpack.dll.js var webpack = require(&apos;webpack&apos;) module.exports = { output: { path: &apos;./dll&apos;, filename: &apos;[name].js&apos;, /** * output.library * 将会定义为 window.${output.library} * 在这次的例子中，将会定义为`window.vendor_library` */ library: &apos;[name]_library&apos;, libraryTarget: &apos;commonjs2&apos; }, entry: { // 入口，依赖的外部模块 vendor: [ &apos;react&apos;, &apos;react-dom&apos;, &apos;react-router&apos;, &apos;redux&apos;, &apos;react-redux&apos;, &apos;redux-thunk&apos;, &apos;semantic-ui-react&apos;, &apos;lodash&apos;, &apos;echarts&apos;, &apos;axios&apos; ] }, plugins: [ new webpack.DllPlugin({ /** * path * 定义 manifest 文件生成的位置 * [name]的部分由entry的名字替换 */ path: &apos;./dll/[name]-manifest.json&apos;, /** * name * dll bundle 输出到那个全局变量上 * 和 output.library 一样即可。 */ name: &apos;[name]&apos;, context: __dirname }) ] } 生成dll文件 执行./node_modules/.bin/webpack --config build/webpack.config.js。 请在每次依赖的模块更改时重新执行这个命令 在index.html中引入dll文件 这一步必不可少，之前因为少了这一步，一直报 vendor_library not defined //这个模块的引入必须在自定义文件的入口之前 &lt;script src=&quot;dist/dll/vendor.dll.js&quot;&gt;&lt;/script&gt; webpack.config.js var webpack = require(&apos;webpack&apos;) module.exports = { output: { path: __dirname, filename: &apos;[name].bundle.js&apos;, }, entry: { app: [&apos;./app.js&apos;] }, plugins: [ new webpack.DllReferencePlugin({ context: __dirname, manifest: require(&apos;./dll/test-manifest.json&apos;), sourceType: &apos;commonjs2&apos;, name: &apos;./dll/test.js&apos; }) ] } BugFixed配置中常可能会出现的问题： vendor not defined : 模块没有在html中引入，在根目录文件夹中加入script标签引入dll文件。 打包时间没有变快： 检查下webpack.config.js的context是否和webpack.config.js的一致，不一致的话保持一致，一般这个context的默认值是开发项目的根路径。 参考 Webpack Plugins we been keepin on the DLL","raw":null,"content":null,"categories":[{"name":"webpack","slug":"webpack","permalink":"http://cc2victoria.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://cc2victoria.github.io/tags/webpack/"},{"name":"DLLPlugin","slug":"DLLPlugin","permalink":"http://cc2victoria.github.io/tags/DLLPlugin/"},{"name":"DllReferencePlugin","slug":"DllReferencePlugin","permalink":"http://cc2victoria.github.io/tags/DllReferencePlugin/"}]},{"title":"php 安装和开启外部扩展库","slug":"php-安装和开启外部扩展库","date":"2017-04-26T15:49:08.000Z","updated":"2017-08-15T16:23:55.027Z","comments":true,"path":"2017/04/26/php-安装和开启外部扩展库/","link":"","permalink":"http://cc2victoria.github.io/2017/04/26/php-安装和开启外部扩展库/","excerpt":"\nphp 安装和开启外部扩展库不得不说，由于php的扩展问题，我在安装和运行php相关项目的时候遇到了很多的坑。例如之前搭建php的Laravel框架，以及最近搭建的 phpmyadmin项目，都遇到了不少缺少库的问题：由于缺少像openssl、mysqli、postgres等外部扩展库，导致程序不能正常运行。但是我们项目通常用到的php是已经编译好的，而且服务器上的安装包的外部扩展不是很全。所以不能通过重新编译php的办法来解决这个问题，且重新编译的话可能导致其他很多的问题。\n是不是很绝望？","text":"php 安装和开启外部扩展库不得不说，由于php的扩展问题，我在安装和运行php相关项目的时候遇到了很多的坑。例如之前搭建php的Laravel框架，以及最近搭建的 phpmyadmin项目，都遇到了不少缺少库的问题：由于缺少像openssl、mysqli、postgres等外部扩展库，导致程序不能正常运行。但是我们项目通常用到的php是已经编译好的，而且服务器上的安装包的外部扩展不是很全。所以不能通过重新编译php的办法来解决这个问题，且重新编译的话可能导致其他很多的问题。 是不是很绝望？经过一番折腾，终于找到解决方法，整理如下： 检测扩展首先检查下扩展有没有加载，如果已经加载了，那基本是99%的可能性确定问题不是出现在扩展库这个地方了。 phpinfo()利用phpinfo()这个方法可以查看当前安装的php包含的扩展有哪些。 bugfixed在安装的时候我遇到了一个很难发现的bug: 在linux端通过php -m命令，我看到了一些我已经安装的扩展，但是在浏览器端通过phpinfo()方法，却发现缺少很多已经安装的库。后来找到原因，Apache中配置的php.ini的位置不对。如果出现类似的问题，不妨检查下Apache根目录下conf文件夹中的http.conf的配置是否正确 安装和开启废话辣么多，终于可以开始说正题了。windows环境新增外部扩展的方法请参考php开启openssl的方法,openssl安装。本文主要介绍linux centos7的安装方法。 php版本： php-5.6.4 这个地方由于我们服务器上的安装包内的文件不是很全，官网上下载也不是很方便，所以这个地方推荐用搜狐的镜像来下载。地址为：http://mirrors.sohu.com/php/ 首先，进入到我们的主机： # 下载对应的php到/opt/php目录下 cd /opt/php wget http://mirrors.sohu.com/php/php-5.6.4.tar.gz # 解压 tar zxvf php-5.6.4.tar.gz # 进入PHP的openssl扩展模块目录 cd php-5.6.4/ext/openssl/ /opt/php/bin/phpize # 这里为你自己的phpize路径，如果找不到，使用whereis phpize查找 # 执行后，发现错误 无法找到config.m4 ，config0.m4就是config.m4。直接重命名 mv config0.m4 config.m4 /opt/php/bin/phpize ./configure --with-openssl --with-php-config=/opt/php/bin/php-config make make install # 安装完成后，会返回一个.so文件（openssl.so）的目录。在此目录下把openssl.so 文件拷贝到你在php.ini 中指定的 extension_dir 下（在php.ini文件中查找：extension_dir =），我这里的目录是 var/www/php5/lib/php/extensions # 编辑php.ini文件，在文件最后添加 extension=openssl.so # 重启Apache即可 /opt/apache2/bin/httpd restart","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://cc2victoria.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://cc2victoria.github.io/tags/php/"}]},{"title":"linux 常用命令","slug":"linux-常用命令","date":"2017-03-24T13:57:01.000Z","updated":"2017-08-15T16:23:46.355Z","comments":true,"path":"2017/03/24/linux-常用命令/","link":"","permalink":"http://cc2victoria.github.io/2017/03/24/linux-常用命令/","excerpt":"\n\n基本软件：\n拷贝  apache ngnix php \ncommon 一键安装环境\ntar\n解压 tar -zvxf  v  查看过程\n压缩 tar -zvcf \n\n\n添加执行权限 \nchmod +x 可执行 w 写 r读 d目录\nchmod +755","text":"基本软件： 拷贝 apache ngnix php common 一键安装环境 tar 解压 tar -zvxf v 查看过程 压缩 tar -zvcf 添加执行权限 chmod +x 可执行 w 写 r读 d目录 chmod +755 执行 ./install.sh () 默认系统执行权限（不推荐）：/bin/ssh install.sh 查看执行脚本 apache启动脚本 danahttpd 查看指令详细信息，以ps为例 man ps ps –help ps 命令使用（查看服务是否启动） s ystemctl status danahttpd ps aux | grep dana | grep -v grep ps -ef | grep dana 启动服务 systemctl start 服务名 进入 init.d目录下，通过 ./ 启动 如： ./ngnix restart ngnix 位置 /etc/ngnix/ngnix.d 可以通过安装脚本查看 vim ：set nu 设置代码行号 非插入状态： 行数 + G 如：80 G 访问底部 G + shift 访问顶部 gg 退出 ：wq :q :q! 远程传输 scp 拷贝 cp 和 scp（建议用于单个文件拷贝） scp 文件 root@192.168.1.203:/home scp -P 端口号 sr（源文件） dest（目标文件） scp -P 5222 root@180.168.94.118:/jp,e/test.file /home/ scp -P 5222 root@180.168.94.118:/home/test.file root@192.168.1.3:/home/ (端口必须一致) 远程连接 ssh 安装 yum install XXX yum search mysql (查找版本 安装时补全版本号) yum update（更新安装仓库） 安装对应安装包目录 /var/cache/yum/xb6_64 安装.rpm 格式的文件 rpm -ivh xxx.rpm 查看软件是否安装： rpm -qa|grep python 删除 rpm -e xxx 查看端口号活动 netstat netstat -anp|grep cayman 挂载 查看挂载 lsbsk 格式化 mkfs.xfs -f /dev/sdd 挂载 mount /dev/sdd /home/ 查看挂载 df -hT 软连接 -s ln -s dest sr 查看主机名称 /etc/hosts 查看ssh的信息 /etc/.ssh/","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"http://cc2victoria.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://cc2victoria.github.io/tags/linux/"}]},{"title":"React 知识学习图谱","slug":"React-知识图谱","date":"2016-12-14T07:17:31.000Z","updated":"2017-08-15T16:24:17.000Z","comments":true,"path":"2016/12/14/React-知识图谱/","link":"","permalink":"http://cc2victoria.github.io/2016/12/14/React-知识图谱/","excerpt":"\n#React 知识学习图谱\n背景由于目前的项目还是使用传统的架构和前端技术。在从特点，应用场景和实战应用几个方面考虑，决定采用React技术栈","text":"#React 知识学习图谱 背景由于目前的项目还是使用传统的架构和前端技术。在从特点，应用场景和实战应用几个方面考虑，决定采用React技术栈：前端技术选型。 React 知识图谱从项目的实际角度出发，列出了如下React的知识学习图谱： 根据以上图谱顺序，列出React项目学习路线如下: 01 React 基础知识 02 Babel 转码: 项目必须。可以直接在js代码中引入，也可以通过命令行将代码转码。 03 路由：非项目必须。主要应用于单页面程序中，管理地址栏。实现页面的路由的映射，参数的解析和传递。 04 React 工程化 03-1 ES6新特性：非项目必需。作为Javascript的最新发布的标准，ES6的新特性和新接口可以让代码更加简洁和优美。ES6新增模块部分跟React的设计能更好的契合。 03-2 服务端 Node：非项目必须。但是如果要用JS来写服务端程序，则需要Node。 NPM：非项目必须。NPM是包管理工具，可以通过NPM来安装项目的一些依赖和管理依赖的版本。 03-3 打包编译：非项目必须。webpack是模块打包和编译工具，主要功能是产品化和模块打包以及将代码编译成浏览器或者Node可识别的代码。 Flux 架构:非项目必须。React只是DOM的抽象层，所以它只能作为应用架构的视图层。而Flux是一种项目应用架构，最大的特点是数据单向流动，如下图： 架构的主要作用是管理 Store 和 View 之间的关系。 06 React组件库的使用方法：React 有很多第三方插件库，如：Bootstrap，D3。第三方插件库的引入和使用，使项目必须。 07 React测试和性能工具:非项目必需。当项目运行到慢慢变得比较大的时候，对于前端性能的分析和代码的测试就变得有必要了 参考 如何学习React | Github React 技术栈系列教程 | Blog react 知识结构 | csdn","raw":null,"content":null,"categories":[{"name":"react","slug":"react","permalink":"http://cc2victoria.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cc2victoria.github.io/tags/react/"}]}]}